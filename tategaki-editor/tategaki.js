// Generated by CoffeeScript 1.7.1
(function() {
  var TategakiEditor;

  $(document).ready(function() {
    window.tategakiEditor = new TategakiEditor("#tategaki");
    $("#ruby").click(function() {
      var furigana;
      furigana = window.prompt("ルビ文字を入力してください", "もじもじ");
      return window.tategakiEditor.ruby(furigana);
    });
    return $("#markup").click(function() {
      var tagName;
      tagName = window.prompt("タグ名を入力してください", "strong");
      return window.tategakiEditor.markup(tagName);
    });
  });

  TategakiEditor = (function() {
    function TategakiEditor(iframeId, options) {
      if (options == null) {
        options = {};
      }
      this.iframeId = iframeId;
      this.colNum = options["colNum"] || 10;
      this.colWidth = options["colWidth"] || 15;
      this.render();
    }

    TategakiEditor.prototype.render = function() {
      var col, cssLink, iframe, _i, _ref;
      iframe = $(this.iframeId);
      this.doc = iframe[0].contentWindow.document;
      this.head = $('head', this.doc);
      this.body = $('body', this.doc);
      cssLink = $('<link rel="stylesheet" type="text/css" href="./tategaki.css"/>');
      this.editor = $('<div contenteditable class="tategaki-editor"></div>').height(this.body.height());
      for (_i = 1, _ref = this.colNum; 1 <= _ref ? _i <= _ref : _i >= _ref; 1 <= _ref ? _i++ : _i--) {
        col = $('<div class="tategaki-column">隣の客はよく柿食う客だ</div>');
        this.editor.append(col);
      }
      this.head.append(cssLink);
      this.body.append(this.editor);
      this.editor.resize((function(_this) {
        return function(e) {
          return console.log(e);
        };
      })(this));
      return this.bindKeyEventHandlers();
    };

    TategakiEditor.prototype.bindKeyEventHandlers = function() {
      return this.editor.on("keydown", (function(_this) {
        return function(e) {
          switch (e.keyCode) {
            case 38:
              _this.moveCaretToPrevChar();
              e.stopPropagation();
              return e.preventDefault();
            case 40:
              _this.moveCaretToNextChar();
              e.stopPropagation();
              return e.preventDefault();
            case 37:
              _this.moveCaretToNextLine();
              e.stopPropagation();
              return e.preventDefault();
            case 39:
              _this.moveCaretToPrevLine();
              e.stopPropagation();
              return e.preventDefault();
          }
        };
      })(this));
    };

    TategakiEditor.prototype.markup = function(elemName, attrs) {
      var e, key, markup, range, sel, val;
      if (attrs == null) {
        attrs = {};
      }
      sel = this.doc.getSelection();
      range = sel.getRangeAt(0);
      if (range.collapsed) {
        return;
      }
      markup = this.doc.createElement(elemName);
      for (key in attrs) {
        val = attrs[key];
        markup.setAttribute(key, val);
      }
      try {
        range.surroundContents(markup);
        sel.removeAllRanges();
        return sel.addRange(range);
      } catch (_error) {
        e = _error;
        return alert("行をまたぐマークアップはできません");
      }
    };

    TategakiEditor.prototype.ruby = function(furigana) {
      var e, furiganaElem, furiganaText, range, rubyElem, sel;
      sel = this.doc.getSelection();
      range = sel.getRangeAt(0);
      if (range.collapsed) {
        return;
      }
      rubyElem = this.doc.createElement("ruby");
      try {
        range.surroundContents(rubyElem);
        furiganaText = this.doc.createTextNode(furigana);
        furiganaElem = this.doc.createElement("rt");
        furiganaElem.appendChild(furiganaText);
        rubyElem.appendChild(furiganaElem);
        sel.removeAllRanges();
        return sel.addRange(range);
      } catch (_error) {
        e = _error;
        return alert("行をまたぐルビは付けられません");
      }
    };

    TategakiEditor.prototype.moveCaretToNextLine = function() {
      var next, range, sel, x, y;
      if (!(next = this.nextColumn())) {
        return;
      }
      x = next.offsetLeft + next.offsetWidth / 2;
      y = this.getCaretCoordinates().top;
      try {
        sel = this.doc.getSelection();
        range = this.doc.caretRangeFromPoint(x, y);
        sel.removeAllRanges();
        return sel.addRange(range);
      } catch (_error) {}
    };

    TategakiEditor.prototype.moveCaretToPrevLine = function() {
      var prev, range, sel, x, y;
      if (!(prev = this.prevColumn())) {
        return;
      }
      x = prev.offsetLeft + prev.offsetWidth / 2;
      y = this.getCaretCoordinates().top;
      try {
        sel = this.doc.getSelection();
        range = this.doc.caretRangeFromPoint(x, y);
        sel.removeAllRanges();
        return sel.addRange(range);
      } catch (_error) {}
    };

    TategakiEditor.prototype.getCaretCoordinates = function() {
      var parent, position, range, span;
      range = this.doc.getSelection().getRangeAt(0).cloneRange();
      span = $("<span></span>");
      range.insertNode(span[0]);
      position = $(span).offset();
      parent = span[0].parentNode;
      parent.removeChild(span[0]);
      parent.normalize();
      return position;
    };

    TategakiEditor.prototype.moveCaretToNextChar = function() {
      var el, nextNode, range, sel;
      if (!this.editor.is(":focus")) {
        return null;
      }
      range = this.doc.getSelection().getRangeAt(0).cloneRange();
      sel = this.doc.getSelection();
      el = range.startContainer;
      if (el.length === range.startOffset) {
        nextNode = this.findNextTextNode(el);
        if (!nextNode) {
          return;
        }
        range.setStart(nextNode, 0);
      } else {
        range.setStart(el, range.startOffset + 1);
      }
      sel.removeAllRanges();
      return sel.addRange(range);
    };

    TategakiEditor.prototype.moveCaretToPrevChar = function() {
      var el, prevNode, range, sel;
      if (!this.editor.is(":focus")) {
        return null;
      }
      range = this.doc.getSelection().getRangeAt(0).cloneRange();
      sel = this.doc.getSelection();
      el = range.startContainer;
      if (range.startOffset === 0) {
        prevNode = this.findPrevTextNode(el);
        if (!prevNode) {
          return;
        }
        range.setStart(prevNode, prevNode.length);
        range.setEnd(prevNode, prevNode.length);
      } else {
        range.setStart(el, range.startOffset - 1);
        range.setEnd(el, range.endOffset - 1);
      }
      sel.removeAllRanges();
      return sel.addRange(range);
    };

    TategakiEditor.prototype.findNextTextNode = function(el) {
      if (el.nextSibling) {
        if (el.nextSibling.nodeType === 3) {
          if (el.nextSibling.length > 0) {
            return el.nextSibling;
          } else {
            return this.findNextTextNode(el.nextSibling);
          }
        } else if (el.nextSibling.hasChildNodes()) {
          if (el.nextSibling.firstChild.nodeType === 3) {
            return el.nextSibling.firstChild;
          }
          return this.findNextTextNode(el.nextSibling.firstChild);
        }
      } else {
        while (!el.parentNode.nextSibling) {
          el = el.parentNode;
          if (el === this.editor[0]) {
            return null;
          }
        }
        return this.findNextTextNode(el.parentNode);
      }
    };

    TategakiEditor.prototype.findPrevTextNode = function(el) {
      if (el.previousSibling) {
        if (el.previousSibling.nodeType === 3) {
          if (el.previousSibling.length > 0) {
            return el.previousSibling;
          } else {
            return this.findPrevTextNode(el.previousSibling);
          }
        } else if (el.previousSibling.hasChildNodes()) {
          if (el.previousSibling.lastChild.nodeType === 3) {
            return el.previousSibling.lastChild;
          }
          return this.findPrevTextNode(el.previousSibling.lastChild);
        }
      } else {
        while (!el.parentNode.previousSibling) {
          el = el.parentNode;
          if (el === this.editor[0]) {
            return null;
          }
        }
        return this.findPrevTextNode(el.parentNode);
      }
    };

    TategakiEditor.prototype.getCaretPosition = function() {
      var range;
      if (!this.editor.is(":focus")) {
        return null;
      }
      range = this.doc.getSelection().getRangeAt(0);
      return {
        el: range.startContainer,
        offset: range.startOffset
      };
    };

    TategakiEditor.prototype.setCaretPosition = function(colIndex, offset) {
      var range, sel;
      if (!this.editor.is(":focus")) {
        return null;
      }
      range = this.doc.createRange();
      sel = this.doc.getSelection();
      range.setStart(this.editor[0].childNodes[colIndex], offset);
      range.collapse(true);
      sel.removeAllRanges();
      return sel.addRange(range);
    };

    TategakiEditor.prototype.prevColumn = function() {
      var current;
      if (current = this.currentColumn()) {
        return current.previousSibling;
      } else {
        return null;
      }
    };

    TategakiEditor.prototype.nextColumn = function() {
      var current;
      if (current = this.currentColumn()) {
        return current.nextSibling;
      } else {
        return null;
      }
    };

    TategakiEditor.prototype.currentColumn = function() {
      var node, p;
      if (!this.editor.is(":focus")) {
        return null;
      }
      if (!(node = this.doc.getSelection().focusNode)) {
        return null;
      }
      console.log(node);
      if (node.nodeType === 1) {
        p = node;
      } else {
        p = node.parentElement;
      }
      while (!$(p).hasClass("tategaki-column")) {
        p = p.parentElement;
      }
      return p;
    };

    TategakiEditor.prototype.selectedElement = function() {
      return this.doc.getSelection().focusNode.parentNode;
    };

    TategakiEditor.prototype.getSelection = function() {
      return this.doc.getSelection();
    };

    return TategakiEditor;

  })();

}).call(this);
